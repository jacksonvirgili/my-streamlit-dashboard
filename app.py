# -*- coding: utf-8 -*-
"""Cópia de app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DtDWgPXGW4RqgLzfy1cxAdfjfPh_jn1W
"""

# app.py
# ======================================================
# DASHBOARD – CONSOLIDADO | RANKING E METAS
# ======================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go

# ------------------------------------------------------
# Layout e Título
# ------------------------------------------------------
st.set_page_config(page_title="Acomp. Diário de Vendas FACTA D-1  (Visão 360º)", layout="wide")

#------------------------------------------------------
# Cache e carregamento da base
#------------------------------------------------------

@st.cache_data
def carregar_base():
    df = pd.read_parquet("consolidado.parquet")
    df["Data"] = pd.to_datetime(df["Data"])
    return df

rede = carregar_base()

#-----------------------------------------------------
# Mapa para produtos zerados
#------------------------------------------------------
def padronizar_base_dias_sem_producao(df: pd.DataFrame) -> pd.DataFrame:

    colunas_id = [
        "Data", "Nome_Loja", "Coordenador",
        "Regional", "ano", "mes"
    ]

    # -------------------------------------------------
    # 1️⃣ PRODUTOS NORMAIS (tudo que NÃO é CONSIG)
    # -------------------------------------------------
    df_outros = df[
        colunas_id + ["produto", "dia_sem_producao"]
    ].copy()

    df_outros["dia_sem_producao"] = (
        df_outros["dia_sem_producao"]
        .fillna(1)
        .astype(int)
    )

    # -------------------------------------------------
    # 2️⃣ CONSIG → explode subprodutos
    # -------------------------------------------------
    mapa_consig = {
        "Novo_sem_producao": "CONSIG_NOVO",
        "Refin_sem_producao": "CONSIG_REFIN",
        "Refin_Port_TX_INF_sem_producao": "CONSIG_PORT_TX_INF",
        "PORT_E_Refin_TX_SUP_sem_producao": "CONSIG_PORT_TX_SUP"
    }

    df_consig = df[df["produto"] == "CONSIG"][
        colunas_id + list(mapa_consig.keys())
    ].copy()

    df_consig = df_consig.melt(
        id_vars=colunas_id,
        value_vars=list(mapa_consig.keys()),
        var_name="subproduto",
        value_name="dia_sem_producao"
    )

    df_consig["produto"] = df_consig["subproduto"].map(mapa_consig)

    df_consig = df_consig[
        colunas_id + ["produto", "dia_sem_producao"]
    ]

    df_consig["dia_sem_producao"] = (
        df_consig["dia_sem_producao"]
        .fillna(1)
        .astype(int)
    )

    # -------------------------------------------------
    # 3️⃣ CONSOLIDA PORT_TX_INF + PORT_TX_SUP
    #    regra: se um produziu → houve produção (max)
    # -------------------------------------------------
    produtos_tx = [
        "CONSIG_PORT_TX_INF",
        "CONSIG_PORT_TX_SUP"
    ]

    df_tx = df_consig[df_consig["produto"].isin(produtos_tx)].copy()

    df_tx_consolidado = (
        df_tx
        .groupby(
            colunas_id,
            as_index=False
        )
        .agg(
            dia_sem_producao=("dia_sem_producao", lambda x: int((x == 1).all()))
        )
    )

    df_tx_consolidado["produto"] = "CONSIG_PORT"

    # -------------------------------------------------
    # 4️⃣ Remove os TX originais e junta tudo
    # -------------------------------------------------
    df_consig_final = df_consig[
        ~df_consig["produto"].isin(produtos_tx)
    ]

    df_final = pd.concat(
        [
            df_outros,
            df_consig_final,
            df_tx_consolidado
        ],
        ignore_index=True
    )

    return df_final

#-------------------------------------------------------
# Base dos KPI's
#------------------------------------------------------
@st.cache_data
def preparar_kpi_mensal(rede: pd.DataFrame) -> pd.DataFrame:

    df = rede.sort_values("Data")

    # ======================================================
    # 1️⃣ AGREGA PRIMEIRO NO NÍVEL DE LOJA
    # ======================================================
    loja = (
        df.groupby(
            ["produto", "Regional", "Nome_Loja", "ano", "mes"],
            as_index=False
        )
        .agg(
            real_acum=("Real_Acumulada", "last"),
            meta_acum=("Meta Mês", "last"),
            produtividade=("produtividade", "mean"),
            qtd_operadores=("Qtd Operadores C/Meta", "last"),
            qtd_ating=("Qtd Operadores Ating. Meta", "last"),
            lojas_zeradas=("dias_sem_producao_acumulado", "max"),
            dias_zerados=("dia_sem_producao", "sum")
        )
    )

    # ======================================================
    # 2️⃣ CONSOLIDA PARA REGIONAL (SOMA DAS LOJAS)
    # ======================================================
    kpi = (
        loja.groupby(
            ["produto", "Regional", "ano", "mes"],
            as_index=False
        )
        .agg(
            real_acum=("real_acum", "sum"),
            meta_acum=("meta_acum", "sum"),
            produtividade=("produtividade", "mean"),
            qtd_operadores=("qtd_operadores", "sum"),
            qtd_ating=("qtd_ating", "sum"),
            lojas_zeradas=("lojas_zeradas", "sum"),
            qtd_lojas=("Nome_Loja", "nunique")
        )
    )

    # ======================================================
    # 3️⃣ KPIs DERIVADOS
    # ======================================================
    kpi["ating_pct"] = (
        kpi["real_acum"] /
        kpi["meta_acum"].replace(0, np.nan)
    ) * 100

    kpi["dispersao_pct"] = (
        1 -
        (kpi["qtd_ating"] / kpi["qtd_operadores"].replace(0, np.nan))
    ) * 100

    kpi["dias_zerados_media"] = (
        kpi["lojas_zeradas"] /
        kpi["qtd_lojas"].replace(0, np.nan)
    )

    return kpi.fillna(0)

# ======================================================
# BASES CANÔNICAS
# ======================================================

base_zerado = padronizar_base_dias_sem_producao(rede)
kpi_mensal = preparar_kpi_mensal(rede)

# ------------------------------------------------------
# Formatações
# ------------------------------------------------------

def aplicar_estilo(fig):
    fig.update_layout(
        template="plotly_white",
        dragmode=False,
        margin=dict(l=10, r=10, t=80, b=40),
        legend=dict(
            orientation="h",
            y=1.05,
            x=0,
            bgcolor="rgba(255,255,255,0.6)",
            bordercolor="rgba(0,0,0,0.1)",
            borderwidth=1
        ),
        font=dict(size=12)
    )
    fig.update_xaxes(tickangle=30)
    return fig


def fmt_moeda(v):
    return f"R$ {v:,.0f}".replace(",", ".")

def montar_customdata(df, cols):
    if not cols:
        return None

    cols_existentes = [c for c in cols if c in df.columns]

    if not cols_existentes:
        return None

    return df[cols_existentes]

# ------------------------------------------------------
# Funções de cálculos para gráficos de realizado/meta
# ------------------------------------------------------

def agregar(df, nivel):
    mapa = {
        "Real_Variacao": "sum",
        "Meta Dia": "sum",
        "Real_Acumulada": "sum",
        "Meta_Acumulada": "sum",
        "Meta Mês": "sum",
        "Real": "sum",
        "DESVIO_DIA": "sum",
        'Qtd Operadores C/Meta': 'sum',
        'Qtd Operadores Ating. Meta': 'sum'

    }

    out = (
        df.groupby(nivel, as_index=False)
        .agg(mapa)
        .sort_values(nivel)
    )

    out["DESVIO_DIA_PCT"] = (
        out["DESVIO_DIA"] /
        out["Meta Dia"].replace(0, np.nan)
    ) * 100

    out["DESVIO_ACUM"] = out["Real_Acumulada"] - out["Meta_Acumulada"]

    out["DESVIO_ACUM_PCT"] = (
        out["DESVIO_ACUM"] /
        out["Meta_Acumulada"].replace(0, np.nan)
    ) * 100

    out = out.fillna(0)
    out = calcular_pct_atingimento(out)
    return out


#--------------------------------------------------
# calulos de produtividade
#--------------------------------------------------
def agregar_produtividade_diaria_com_media(df):
    out = (
        df.groupby("Data", as_index=False)
          .agg({
              "produtividade": "mean",
              "Qtd Operadores C/Meta": "sum",
              "Qtd Operadores Ating. Meta": "sum"
          })
          .sort_values("Data")
    )

    media_mensal = out["produtividade"].mean()
    out["MEDIA_MENSAL"] = media_mensal

    out["DESVIO_MEDIA_MENSAL"] = out["produtividade"] - media_mensal

    out["DESVIO_MEDIA_MENSAL_PCT"] = (
        out["DESVIO_MEDIA_MENSAL"] / media_mensal
        if media_mensal != 0 else 0
    ) * 100

    out = out.fillna(0)
    out = calcular_pct_atingimento(out)
    return out


#------------------------------------------------
# Base de comparação (consultor x média grupo)
#-----------------------------------------------
def construir_base_total_produtividade(
    rede,
    produto,
    regional,
    coordenador,
    loja,
    ano,
    mes
):
    base = rede.copy()

    # -------------------------
    # FILTROS GERAIS
    # -------------------------
    if produto != 'Todos':
        base = base[base['produto'] == produto]

    base = base[
        (base['ano'] == ano) &
        (base['mes'] == mes)
    ]

    # ==================================================
    # LOJA → OUTRAS LOJAS DO MESMO COORDENADOR
    # ==================================================
    if loja != 'Todas':

        # Descobre o coordenador da loja
        coord_loja = (
            base.loc[base['Nome_Loja'] == loja, 'Coordenador']
            .dropna()
            .unique()
        )

        if len(coord_loja) == 0:
            return pd.DataFrame()

        coord_loja = coord_loja[0]

        base = base[
            (base['Coordenador'] == coord_loja) &
            (base['Nome_Loja'] != loja)
        ]

    # ==================================================
    # COORDENADOR → OUTROS COORDENADORES DA REGIONAL
    # ==================================================
    elif coordenador != 'Todos':

        # Descobre a regional do coordenador
        reg_coord = (
            base.loc[base['Coordenador'] == coordenador, 'Regional']
            .dropna()
            .unique()
        )

        if len(reg_coord) == 0:
            return pd.DataFrame()

        reg_coord = reg_coord[0]

        base = base[
            (base['Regional'] == reg_coord) &
            (base['Coordenador'] != coordenador)
        ]

    # ==================================================
    # REGIONAL → OUTRAS REGIONAIS
    # ==================================================
    elif regional != 'Todas':

        base = base[
            base['Regional'] != regional
        ]

    # ==================================================
    # NADA SELECIONADO → MÉDIA DA REDE
    # ==================================================
    else:
        pass

    # -------------------------
    # MÉDIA DIÁRIA DO GRUPO
    # -------------------------
    return (
        base.groupby("Data", as_index=False)
            .agg({
                "produtividade": "mean",
                "Qtd Operadores C/Meta": "sum",
                "Qtd Operadores Ating. Meta": "sum"
            })
            .sort_values("Data")
    )

#------------------------------------------------------
# porcentagem de atingimento
#------------------------------------------------------
def calcular_pct_atingimento(df):
    if (
        "Qtd Operadores C/Meta" not in df.columns or
        "Qtd Operadores Ating. Meta" not in df.columns
    ):
        return df

    df["Atingimento %"] = (
        df["Qtd Operadores Ating. Meta"] /
        df["Qtd Operadores C/Meta"].replace(0, 1)
    ) * 100

    return df


# ------------------------------------------------------
# GRÁFICO BASE CONSOLIDADO
# ------------------------------------------------------
def grafico_consolidado(df, eixo_x, tipo, titulo, label_total=None):

    # -----------------------------
    # EIXO X
    # -----------------------------
    if eixo_x == "Data":
        x = df["Data"].dt.strftime("%d/%m")
    else:
        x = df[eixo_x].astype(str)

    # -----------------------------
    # INICIALIZA (NUNCA DEIXA HOVER DEFAULT)
    # -----------------------------
    y = None
    y_meta = None
    cores = "#EA9411"
    titulo_y = ""
    nome_barra = ""
    hover_barra = None
    label_linha = "Meta"

    # -----------------------------
    # TIPOS DE GRÁFICO ** excluir desvios da média em %
    # -----------------------------
    if tipo == "Diário":
        y = df["Real_Variacao"]
        y_meta = df["Meta Dia"]
        titulo_y = "R$"
        nome_barra = "Realizado"

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Real:</b> R$ %{y:,.2f}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )

    elif tipo == "Acumulado":
        y = df["Real_Acumulada"]
        y_meta = df["Meta_Acumulada"]
        titulo_y = "R$"
        nome_barra = "Realizado"

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Real:</b> R$ %{y:,.2f}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )

    elif tipo == "Desvio Diário (R$)":
        y = df["DESVIO_DIA"]
        titulo_y = "R$"
        nome_barra = "Desvio (R$)"
        cores = ["#EA9411" if v >= 0 else "gray" for v in y]

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Desvio:</b> R$ %{y:.2f}"
            "<extra></extra>"
        )

    elif tipo == "Desvio vs Média (R$)":
        y = df["DESVIO_MEDIA"]
        titulo_y = "R$"
        nome_barra = "Desvio Produtividade"
        cores = ["#EA9411" if v >= 0 else "gray" for v in y]

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            f"<b>Desvio:</b> R$ %{{y:,.2f}}"
            "<extra></extra>"
        )

    elif tipo == "Desvio Acumulado (R$)":
        y = df["DESVIO_ACUM"]
        titulo_y = "R$"
        nome_barra = "Desvio Acumulado"
        cores = ["#EA9411" if v >= 0 else "gray" for v in y]

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Desvio:</b> R$ %{y:,.2f}"
            "<extra></extra>"
        )
    elif tipo == "Produtividade Diária":
        y = df["produtividade"]
        y_meta = df["MEDIA_MENSAL"]
        titulo_y = "Produtividade"
        nome_barra = "Produtividade"
        label_linha = "Média Mensal"

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Produtividade:</b> R$ %{y:,.2f}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )
    elif tipo == "Desvio vs Média Mensal (R$)":
        y = df["DESVIO_MEDIA_MENSAL"]
        titulo_y = "R$"
        nome_barra = "Desvio vs Média Mensal"
        cores = ["#EA9411" if v >= 0 else "gray" for v in y]

        hover_barra = (
            "<b>Data:</b> %{x}<br>"
            "<b>Desvio:</b> R$ %{y:,.2f}"
            "<extra></extra>"
        )

    # -----------------------------
    # CONSTRUÇÃO DO GRÁFICO
    # -----------------------------
    fig = go.Figure()

    fig.add_bar(
        x=x,
        y=y,
        name=nome_barra,
        marker_color=cores,
        customdata=montar_customdata(df, ["Qtd Operadores C/Meta", "Qtd Operadores Ating. Meta","Atingimento %"]),
        hovertemplate=hover_barra
    )

    if y_meta is not None:
        fig.add_scatter(
            x=x,
            y=y_meta,
            name=label_linha,
            mode="lines+markers",
            marker=dict(color="blue"),
            hovertemplate=(
                "<b>Data:</b> %{x}<br>"
                f"<b>{label_linha}:</b> R$ %{{y:,.2f}}"
                "<extra></extra>"
            )
        )


    fig.update_layout(
        title=titulo,
        height=420,
        yaxis_title=titulo_y
    )

    st.plotly_chart(
        aplicar_estilo(fig),
        use_container_width=True
    )



# ------------------------------------------------------
# GRÁFICO COMPARATIVO (ENTIDADE X TOTAL)
# ------------------------------------------------------
def grafico_comparativo(df_sel, df_total, eixo_x, titulo, label_total, label_sel):

    x = df_sel[eixo_x].dt.strftime("%d/%m")

    fig = go.Figure()

    # -----------------------------
    # SELECIONADO
    # -----------------------------
    fig.add_bar(
        x=x,
        y=df_sel["produtividade"],
        name=label_sel,
        marker_color="#EA9411",
        customdata=montar_customdata(
            df_sel,
            ["Qtd Operadores C/Meta", "Qtd Operadores Ating. Meta","Atingimento %"]
        ),
        hovertemplate=(
            "<b>Data:</b> %{x}<br>"
            f"<b>{label_sel}:</b> R$ %{{y:,.2f}}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>% Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )
    )

    # -----------------------------
    # TOTAL DE REFERÊNCIA
    # -----------------------------
    fig.add_bar(
        x=x,
        y=df_total["produtividade"],
        name=label_total,
        marker_color="gray",
        customdata=montar_customdata(
            df_total,
            ["Qtd Operadores C/Meta", "Qtd Operadores Ating. Meta","Atingimento %"]
        ),
        hovertemplate=(
            "<b>Data:</b> %{x}<br>"
            f"<b>{label_total}:</b> R$ %{{y:,.2f}}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )
    )


    fig.update_layout(
        barmode="group",
        title=titulo,
        height=420
    )

    st.plotly_chart(
        aplicar_estilo(fig),
        use_container_width=True
    )

#------------------------------------------------
# Gráfico Produtividade
#-----------------------------------------------

def grafico_produtividade(df, eixo_x, titulo):

    if eixo_x == "Data":
        x = df["Data"].dt.strftime("%d/%m")
    else:
        x = df[eixo_x].astype(str)

    fig = go.Figure()

    fig.add_bar(
        x=x,
        y=df["produtividade"],
        name="Produtividade",
        marker_color="#EA9411",
        hovertemplate=(
            "<b>Data:</b> %{x}<br>"
            "<b>Produtividade:</b> R$ %{y:.2f}<br>"
            "<b>Consultores c/Meta:</b> %{customdata[0]}<br>"
            "<b>Consultores Ating:</b> %{customdata[1]}<br>"
            "<b>Atingimento:</b> %{customdata[2]:.1f}%"
            "<extra></extra>"
        )
    )

    fig.update_layout(
        title=titulo,
        height=420,
        yaxis_title="Produtividade"
    )

    st.plotly_chart(
        aplicar_estilo(fig),
        use_container_width=True
    )

# ======================================================
# APP
# ======================================================

st.title("Acomp. Diário de Vendas FACTA M-1 (Visão 360º)")

pagina = st.selectbox("Página", ["Painel Executivo","Desempenho Comercial","Produtividade & Comparativos", "Ranking & Metas", "Análise por Produto"])

#========================================================
# Página inicial
#========================================================
if pagina == "Painel Executivo":

    ano_kpi = st.sidebar.selectbox(
        "Ano",
        sorted(kpi_mensal["ano"].unique())
    )

    mes_kpi = st.sidebar.selectbox(
        "Mês",
        sorted(kpi_mensal["mes"].unique())
    )

    # -------------------------------------------------
    # LISTA DE PRODUTOS
    # -------------------------------------------------
    produtos = sorted(kpi_mensal["produto"].unique())

    for produto in produtos:

        df = kpi_mensal[
            (kpi_mensal["produto"] == produto) &
            (kpi_mensal["ano"] == ano_kpi) &
            (kpi_mensal["mes"] == mes_kpi)
        ].copy()

        if df.empty:
            continue

        # -------------------------------------------------
        # RENOMEAR COLUNAS
        # -------------------------------------------------
        df.rename(columns={
            "real_acum": "Real Acum",
            "meta_acum": "Meta Acum",
            "ating_pct": "Ating (%)",
            "produtividade": "Produtividade",
            "dispersao_pct": "Dispersão (%)",
            "dias_zerados_media": "Média de dias zerados p/Loja",
            "qtd_operadores": "Qtd Operadores",
            "qtd_ating": "Qtd Ating"
        }, inplace=True)

        # -------------------------------------------------
        # MÉTRICAS DERIVADAS
        # -------------------------------------------------
        df["Ating (%)"] = (df["Real Acum"] / df["Meta Acum"]) * 100
        df["Ating (%)"] = df["Ating (%)"]
        df["Dispersão (%)"] = df["Dispersão (%)"]

        # -------------------------------------------------
        # Cria df_fmt antes de gerar a coluna combinada
        # -------------------------------------------------
        df_fmt = df.copy()
        df_fmt["Real Acum"] = df_fmt["Real Acum"].map(lambda x: f"R$ {x:,.2f}".replace(",", "."))
        df_fmt["Meta Acum"] = df_fmt["Meta Acum"].map(lambda x: f"R$ {x:,.2f}".replace(",", "."))
        df_fmt["Produtividade"] = df_fmt["Produtividade"].map(lambda x: f"R$ {x:,.2f}")
        df_fmt["Qtd Operadores"] = df["Qtd Operadores"].astype(int)
        df_fmt["Qtd Ating"] = df["Qtd Ating"].astype(int)
        df_fmt["Dispersão (%)"] = df_fmt["Dispersão (%)"].map(lambda x: f"{x:.2f}%")
        df_fmt["Média de dias zerados p/Loja"] = df_fmt["Média de dias zerados p/Loja"].round(0)

        # -------------------------------------------------
        # Barra textual Real x Meta com percentual
        # -------------------------------------------------
        def barra_com_percentual(real, meta, largura=18):
            pct = min(real / meta, 1)
            preenchido = int(pct * largura)
            barra = "█" * preenchido + "░" * (largura - preenchido)
            percentual = (real / meta) * 100
            return barra, percentual  # retorna barra e valor separado

        # Criar colunas separadas
        df[["Barra", "Ating"]] = df.apply(
            lambda x: pd.Series(barra_com_percentual(x["Real Acum"], x["Meta Acum"])),
            axis=1
        )

        # Lista de cores do percentual
        def cor_percentual(pct):
            if pct >= 100:
                return "#0070C0"
            elif pct >= 80:
                return "#00B050"
            elif pct >= 70:
                return "#FFC000"
            elif pct >= 60:
                return "#FF0000"
            else:
                return "#7030A0"

        cores = df["Ating"].apply(cor_percentual).tolist()

        # Coluna combinada no df_fmt
        df_fmt["Real x Meta (%)"] = df["Barra"] + " " + df["Ating"].map(lambda x: f"{x:.2f}%")

        def cor_dispersao(disp):
            if disp <= 20:
                return "#0070C0"
            elif disp <= 45:
                return "#00B050"
            elif disp < 70:
                return "#FFC000"
            elif disp >= 70:
                return "#FF0000"
            else:
                return "#FF0000"

        cores_dispersao = df["Dispersão (%)"].apply(cor_dispersao).tolist()

        # -------------------------------------------------
        # Linha agregada REDE
        # -------------------------------------------------
        linha_rede = {
            "Regional": "REDE",
            "Real Acum": df["Real Acum"].sum(),
            "Meta Acum": df["Meta Acum"].sum(),
            "Produtividade": df["Produtividade"].mean(),
            "Qtd Operadores": df["Qtd Operadores"].sum(),
            "Qtd Ating": df["Qtd Ating"].sum(),
            "Dispersão (%)": df["Dispersão (%)"].mean(),
            "Média de dias zerados p/Loja": df["Média de dias zerados p/Loja"].mean()
        }

        cor_rede_dispersao = cor_dispersao(linha_rede["Dispersão (%)"])

        # Barra + percentual da linha agregada
        barra, ating = barra_com_percentual(linha_rede["Real Acum"], linha_rede["Meta Acum"])
        linha_rede["Real x Meta (%)"] = f"{barra} {ating:.2f}%"
        cor_rede = cor_percentual(ating)


        # Formatar os números da linha REDE igual ao df_fmt
        linha_rede["Real Acum"] = f"R$ {linha_rede['Real Acum']:,.2f}".replace(",", ".")
        linha_rede["Meta Acum"] = f"R$ {linha_rede['Meta Acum']:,.2f}".replace(",", ".")
        linha_rede["Produtividade"] = f"R$ {linha_rede['Produtividade']:,.2f}"
        linha_rede["Qtd Operadores"] = int(linha_rede["Qtd Operadores"])
        linha_rede["Qtd Ating"] = int(linha_rede["Qtd Ating"])
        linha_rede["Dispersão (%)"] = f"{linha_rede['Dispersão (%)']:.2f}%"
        linha_rede["Média de dias zerados p/Loja"] = round(linha_rede["Média de dias zerados p/Loja"], 0)

        # Adicionar linha REDE ao df_fmt
        df_fmt = pd.concat([df_fmt, pd.DataFrame([linha_rede])], ignore_index=True)
        cores.append(cor_rede)  # adiciona cor da REDE à lista de cores
        cores_dispersao.append(cor_rede_dispersao)

        # -------------------------------------------------
        # TABELA VISUAL COM LINHA REDE SOMBREADA
        # -------------------------------------------------
        st.markdown(f"<h3 style='text-align: center; margin-bottom: 5px;'>{produto}</h3>", unsafe_allow_html=True)

        fig_table = go.Figure()

        # Fundo: padrão branco e último (REDE) sombreado
        fundo = [["white"]*len(df_fmt) for _ in range(9)]  # 9 colunas
        sombreado = "#E0E0E0"
        for col_idx in range(9):
            fundo[col_idx][-1] = sombreado  # linha REDE sombreada

        df_fmt["Dispersão (%)"] = df_fmt["Dispersão (%)"].apply(lambda x: f"<b>{x}</b>")

        fig_table.add_trace(
            go.Table(
                header=dict(
                    values=[
                        "Regional",
                        "Realizado Mensal",
                        "Meta Mensal",
                        "Atingimento (%)",
                        "Produtividade Diária (Média por Consultor)",
                        "Qtd. Operadores c/Meta",
                        "Qtd. Atingindo Meta",
                        "Dispersão (%)",
                        "Média de dias zerados p/Loja"
                    ],
                    fill_color="#F2F2F2",
                    align="center",
                    font=dict(size=12, color="black")
                ),
                cells=dict(
                    values=[
                        df_fmt["Regional"],
                        df_fmt["Real Acum"],
                        df_fmt["Meta Acum"],
                        df_fmt["Real x Meta (%)"],  # Barra + percentual
                        df_fmt["Produtividade"],
                        df_fmt["Qtd Operadores"],
                        df_fmt["Qtd Ating"],
                        df_fmt["Dispersão (%)"],
                        df_fmt["Média de dias zerados p/Loja"]
                    ],
                    align="center",
                    height=28,
                    fill_color=fundo,
                    font_color=[
                        ["black"]*len(df_fmt),  # Regional
                        ["black"]*len(df_fmt),  # Real Acum
                        ["black"]*len(df_fmt),  # Meta Acum
                        cores,                   # Real x Meta (%) -> cor do número
                        ["black"]*len(df_fmt),  # Produtividade
                        ["black"]*len(df_fmt),  # Qtd Operadores
                        ["black"]*len(df_fmt),  # Qtd Ating
                        cores_dispersao,  # Dispersão (%)
                        ["black"]*len(df_fmt)   # Média de dias zerados
                    ]
                )
            )
        )

        fig_table.update_layout(height=450)

        st.plotly_chart(
            aplicar_estilo(fig_table),
            use_container_width=True
        )

# ======================================================
# CONSOLIDADO
# ======================================================

elif pagina == "Desempenho Comercial":

    st.sidebar.header("Filtros")

    tipo = st.radio(
        "Visualização",
        ["Diário", "Acumulado"],
        horizontal=True
    )

#----------------------------------------------------
# filtros
#------------------------------------------------------

    produto = st.sidebar.selectbox(
        "Produto",
        ['Todos'] + sorted(rede['produto'].dropna().unique())
    )
    regional = st.sidebar.selectbox(
        "Regional",
        ['Todas'] + sorted(rede['Regional'].dropna().unique())
    )

    if regional != 'Todas':
        coords_disp = (
            rede[rede['Regional'] == regional]['Coordenador']
            .dropna()
            .unique()
        )
    else:
        coords_disp = rede['Coordenador'].dropna().unique()

    coordenador = st.sidebar.selectbox(
        "Coordenador",
        ['Todos'] + sorted(coords_disp)
    )
    base_lojas = rede.copy()

    if regional != 'Todas':
        base_lojas = base_lojas[base_lojas['Regional'] == regional]

    if coordenador != 'Todos':
        base_lojas = base_lojas[base_lojas['Coordenador'] == coordenador]

    lojas_disp = base_lojas['Nome_Loja'].dropna().unique()

    loja = st.sidebar.selectbox(
        "Loja",
        ['Todas'] + sorted(lojas_disp)
    )
    ano = st.sidebar.selectbox(
        "Ano",
        sorted(rede['ano'].dropna().unique())
    )

    mes = st.sidebar.selectbox(
        "Mês",
        sorted(rede['mes'].dropna().unique())
    )
    eixo_x = "Data"

    # --------------------------------------------------
    # BASE SELECIONADA
    # --------------------------------------------------
    base_sel = rede.copy()

    if produto != 'Todos':
        base_sel = base_sel[base_sel['produto'] == produto]

    if regional != 'Todas':
        base_sel = base_sel[base_sel['Regional'] == regional]

    if coordenador != 'Todos':
        base_sel = base_sel[base_sel['Coordenador'] == coordenador]

    if loja != 'Todas':
        base_sel = base_sel[base_sel['Nome_Loja'] == loja]

    base_sel = base_sel[
        (base_sel['ano'] == ano) &
        (base_sel['mes'] == mes)
    ]

    eixo_x = "Data"
    df_sel = agregar(base_sel, eixo_x)

    # --------------------------------------------------
    # GRÁFICOS
    # --------------------------------------------------
    if tipo == "Diário":

        grafico_consolidado(
            df_sel,
            eixo_x,
            "Diário",
            f"Diário — {mes}/{ano}"
        )

        grafico_consolidado(
            df_sel,
            eixo_x,
            "Desvio Diário (R$)",
            f"Desvios da Meta — {mes}/{ano}"
        )

    elif tipo == "Acumulado":

        grafico_consolidado(
            df_sel,
            eixo_x,
            "Acumulado",
            f"Acumulado — {mes}/{ano}"
        )

        grafico_consolidado(
            df_sel,
            eixo_x,
            "Desvio Acumulado (R$)",
            f"Desvio da Meta — {mes}/{ano}"
        )

#----------------------------------------
#
#----------------------------------------

elif pagina == "Produtividade & Comparativos":

    st.sidebar.header("Filtros")

    modo_comp = st.checkbox("Comparar com Média do Grupo")

#----------------------------------------------------
# filtros do comparativo
#------------------------------------------------------

    produto = st.sidebar.selectbox(
        "Produto",
        ['Todos'] + sorted(rede['produto'].dropna().unique())
    )

    # -----------------------------
    # REGIONAL
    # -----------------------------
    regional = st.sidebar.selectbox(
        "Regional",
        ['Todas'] + sorted(rede['Regional'].dropna().unique())
    )

    # -----------------------------
    # COORDENADOR (DEPENDE DA REGIONAL)
    # -----------------------------
    if regional != 'Todas':
        coords_disp = (
            rede[rede['Regional'] == regional]['Coordenador']
            .dropna()
            .unique()
        )
    else:
        coords_disp = rede['Coordenador'].dropna().unique()

    coordenador = st.sidebar.selectbox(
        "Coordenador",
        ['Todos'] + sorted(coords_disp)
    )

    # -----------------------------
    # LOJA (DEPENDE DE REGIONAL + COORDENADOR)
    # -----------------------------
    base_lojas = rede.copy()

    if regional != 'Todas':
        base_lojas = base_lojas[base_lojas['Regional'] == regional]

    if coordenador != 'Todos':
        base_lojas = base_lojas[base_lojas['Coordenador'] == coordenador]

    lojas_disp = base_lojas['Nome_Loja'].dropna().unique()

    loja = st.sidebar.selectbox(
        "Loja",
        ['Todas'] + sorted(lojas_disp)
    )

    # -----------------------------
    # PERÍODO
    # -----------------------------
    ano = st.sidebar.selectbox(
        "Ano",
        sorted(rede['ano'].dropna().unique())
    )

    mes = st.sidebar.selectbox(
        "Mês",
        sorted(rede['mes'].dropna().unique())
    )

    # --------------------------------------------------
    # EIXO SEMPRE TEMPORAL
    # --------------------------------------------------
    eixo_x = "Data"

    # --------------------------------------------------
    # BASE SELECIONADA (Agrega filtros)
    # --------------------------------------------------
    base_sel = rede.copy()

    if produto != 'Todos':
        base_sel = base_sel[base_sel['produto'] == produto]

    if regional != 'Todas':
        base_sel = base_sel[base_sel['Regional'] == regional]

    if coordenador != 'Todos':
        base_sel = base_sel[base_sel['Coordenador'] == coordenador]

    if loja != 'Todas':
        base_sel = base_sel[base_sel['Nome_Loja'] == loja]

    base_sel = base_sel[
        (base_sel['ano'] == ano) &
        (base_sel['mes'] == mes)
    ]
#--------------------------------
# modelo de agregação
#-------------------------------
    df_sel = agregar_produtividade_diaria_com_media(base_sel)

    # ==================================================
    # COMPARATIVO → SOMENTE DIÁRIO
    # ==================================================
    if modo_comp and (
        produto != 'Todos' or
        regional != 'Todas' or
        coordenador != 'Todos' or
        loja != 'Todas'
    ):

        base_total = construir_base_total_produtividade(
            rede,
            produto,
            regional,
            coordenador,
            loja,
            ano,
            mes
        )

        df_total = base_total.copy()

        df_total = df_total[
            df_total["Data"].isin(df_sel["Data"])
        ]

        # ✅ AQUI é o lugar correto
        df_total = calcular_pct_atingimento(df_total)
        df_sel   = calcular_pct_atingimento(df_sel)

        # ----------------------------------------
        # DESVIO VS MÉDIA (agragação comparativo)
        # ----------------------------------------
        df_comp = df_sel.merge(
            df_total[["Data", "produtividade"]],
            on="Data",
            how="left",
            suffixes=("", "_MEDIA")
        )

        df_comp["DESVIO_MEDIA"] = (
            df_comp["produtividade"] -
            df_comp["produtividade_MEDIA"]
        )

        df_comp["DESVIO_MEDIA_PCT"] = (
            df_comp["DESVIO_MEDIA"] /
            df_comp["produtividade_MEDIA"].replace(0, np.nan)
        ) * 100

        df_comp = df_comp.fillna(0)


        # ----------------------------------------
        # LABEL DINÂMICO DO SELECIONADO
        # ----------------------------------------
        if loja != 'Todas':
            label_sel = loja
        elif coordenador != 'Todos':
            label_sel = coordenador
        elif regional != 'Todas':
            label_sel = regional
        else:
            label_sel = "Rede"

        # ----------------------------------------
        # LABEL DINÂMICO DO TOTAL (MÉDIA)
        # ----------------------------------------
        if loja != 'Todas':
            label_total = "Média das Lojas do Coordenador"
        elif coordenador != 'Todos':
            label_total = "Média dos Coordenadores da Regional"
        elif regional != 'Todas':
            label_total = "Média das Regionais"
        else:
            label_total = "Média da Rede"

        # -----------------------------
        # GRÁFICO PRODUTIVIDADE
        # -----------------------------

        grafico_comparativo(
            df_sel,
            df_total,
            eixo_x,
            f"Produtividade — {label_sel}  <>  {label_total}",
            label_total,
            label_sel
        )

        # -----------------------------
        # DESVIO VS MÉDIA (R$)
        # -----------------------------

        grafico_consolidado(
            df_comp,
            eixo_x,
            "Desvio vs Média (R$)",
            f"Desvio em Relação a {label_total} — {mes}/{ano}",
            label_total=label_total
        )

    else:
        # ==================================================
        # CONSOLIDADO SIMPLES (SEM COMPARATIVO)
        # ==================================================
        grafico_consolidado(
            df_sel,
            eixo_x,
            "Produtividade Diária",
            f"Média de Produção por Consultor — {mes}/{ano}"
        )

        grafico_consolidado(
            df_sel,
            eixo_x,
            "Desvio vs Média Mensal (R$)",
            f"Desvio da Média Mensal — {mes}/{ano}"
        )



# ======================================================
# RANKING E METAS
# ======================================================
elif pagina in ["Ranking & Metas"]:

    st.sidebar.header("Filtros")

    # --------------------------------
    # DATAFRAME BASE PARA FILTROS
    # --------------------------------
    df_filtro = rede.copy()

    # --------------------------------
    # REGIONAL
    # --------------------------------
    regional = st.sidebar.selectbox(
        "Regional",
        ["Todas"] + sorted(df_filtro["Regional"].dropna().unique())
    )

    if regional != "Todas":
        df_filtro = df_filtro[df_filtro["Regional"] == regional]

    # --------------------------------
    # COORDENADOR (RESTRITO À REGIONAL)
    # --------------------------------
    coordenador = st.sidebar.selectbox(
        "Coordenador",
        ["Todos"] + sorted(df_filtro["Coordenador"].dropna().unique())
    )

    if coordenador != "Todos":
        df_filtro = df_filtro[df_filtro["Coordenador"] == coordenador]
        grupo = "Nome_Loja"
    else:
        grupo = "Coordenador"

    # --------------------------------
    # PRODUTO (RESTRITO À REGIONAL + COORDENADOR)
    # --------------------------------
    produto = st.sidebar.selectbox(
        "Produto",
        ["Todos"] + sorted(df_filtro["produto"].dropna().unique())
    )

    if produto != "Todos":
        df_filtro = df_filtro[df_filtro["produto"] == produto]

    # --------------------------------
    # ANO / MÊS (PODEM OU NÃO SER ENCADEADOS)
    # --------------------------------
    ano = st.sidebar.selectbox(
        "Ano",
        sorted(df_filtro["ano"].dropna().unique())
    )

    mes = st.sidebar.selectbox(
        "Mês",
        sorted(df_filtro["mes"].dropna().unique())
    )

    # --------------------------------
    # VISUALIZAÇÃO
    # --------------------------------
    modo_rank = st.radio(
        "Visualização", ["Ranking", "Desvio"], horizontal=True
    )

    # --------------------------------
    # APLICA FILTROS FINAIS
    # --------------------------------
    df = df_filtro[
        (df_filtro["ano"] == ano) &
        (df_filtro["mes"] == mes)
    ]

    # ------------------------------
    # AGREGAÇÃO
    # ------------------------------
    ranking = (
        df.groupby(grupo, as_index=False)
          .agg({
              "Real_Variacao": "sum",
              "Meta Dia": "sum"
          })
    )

    ranking["Desvio"] = ranking["Real_Variacao"] - ranking["Meta Dia"]

    # ------------------------------
    # FUNÇÃO PARA QUEBRAR LABEL
    # ------------------------------
    def quebrar_label(texto, max_chars=18):
        palavras = texto.split()
        linhas = []
        linha_atual = ""

        for palavra in palavras:
            if len(linha_atual) + len(palavra) <= max_chars:
                linha_atual += (" " if linha_atual else "") + palavra
            else:
                linhas.append(linha_atual)
                linha_atual = palavra

        linhas.append(linha_atual)
        return "<br>".join(linhas)

    ranking["label_wrap"] = ranking[grupo].apply(quebrar_label)

    # ------------------------------
    # ORDENAÇÃO
    # ------------------------------
    if modo_rank == "Ranking":
        ranking.sort_values("Real_Variacao", inplace=True)
    else:
        ranking.sort_values("Desvio", inplace=True)

    # ------------------------------
    # GRÁFICOS
    # ------------------------------
    if modo_rank == "Ranking":

        fig = go.Figure()

        fig.add_bar(
            y=ranking["label_wrap"],
            x=ranking["Real_Variacao"],
            orientation="h",
            marker_color="#EA9411",
            name="Real Acumulado",
            hovertemplate="<b>%{y}</b><br>Real: R$ %{x:,.0f}<extra></extra>"
        )

        fig.add_scatter(
            y=ranking["label_wrap"],
            x=ranking["Meta Dia"],
            mode="markers",
            marker=dict(size=12, symbol="diamond", color="blue"),
            name="Meta Acumulada",
            hovertemplate="<b>%{y}</b><br>Meta: R$ %{x:,.0f}<extra></extra>"
        )

        fig.update_layout(
            title=dict(text="Ranking", y=0.97, yanchor="top", x=0.5, xanchor="center"),
            height=len(ranking) * 60,
            yaxis=dict(automargin=True)
        )

        st.plotly_chart(aplicar_estilo(fig), use_container_width=True)

    else:

        fig = go.Figure()

        fig.add_bar(
            y=ranking["label_wrap"],
            x=ranking["Desvio"],
            orientation="h",
            marker_color=[
                "#EA9411" if x >= 0 else "gray"
                for x in ranking["Desvio"]
            ],
            hovertemplate="<b>%{y}</b><br>Desvio: R$ %{x:,.0f}<extra></extra>"
        )

        fig.update_layout(
            title="Ranking",
            height=len(ranking) * 60,
            yaxis=dict(automargin=True),
            showlegend=False,
            bargap=0.20
        )

        st.plotly_chart(aplicar_estilo(fig), use_container_width=True)

    # ------------------------------
    # TABELA
    # ------------------------------
    st.subheader("Tabela Metas")

    ranking["Desvio %"] = (
        ranking["Desvio"]
        / ranking["Meta Dia"].replace(0, np.nan)
        * 100
    ).map(lambda x: f"{x:.2f}%")

    st.dataframe(ranking, use_container_width=True)

  #-----------------------------------
  # Produtos
  #-------------------------------------
elif pagina == "Análise por Produto":

    st.sidebar.header("Filtros")

    # --------------------------------------------------
    # BASE CANÔNICA (produto já normalizado)
    # --------------------------------------------------
    df_base = base_zerado.copy()
    df_base["Data"] = pd.to_datetime(df_base["Data"])

    # --------------------------------------------------
    # 1️⃣ PRODUTO (OBRIGATÓRIO)
    # --------------------------------------------------
    produto = st.sidebar.selectbox(
        "Produto",
        sorted(df_base["produto"].unique())
    )
    df_base = df_base[df_base["produto"] == produto]

    # --------------------------------------------------
    # 2️⃣ REGIONAL (OBRIGATÓRIO)
    # --------------------------------------------------
    regional = st.sidebar.selectbox(
        "Regional",
        sorted(df_base["Regional"].dropna().unique())
    )
    df_base = df_base[df_base["Regional"] == regional]

    # --------------------------------------------------
    # 3️⃣ COORDENADOR (OBRIGATÓRIO)
    # --------------------------------------------------
    coordenador = st.sidebar.selectbox(
        "Coordenador",
        sorted(df_base["Coordenador"].dropna().unique())
    )
    df_base = df_base[df_base["Coordenador"] == coordenador]

    # --------------------------------------------------
    # 4️⃣ TEMPO (Ano e Mês obrigatórios)
    # --------------------------------------------------
    ano = st.sidebar.selectbox(
        "Ano",
        sorted(df_base["ano"].unique())
    )
    df_base = df_base[df_base["ano"] == ano]

    mes = st.sidebar.selectbox(
        "Mês",
        sorted(df_base["mes"].unique())
    )
    df_base = df_base[df_base["mes"] == mes]

    # --------------------------------------------------
    # CÁLCULO DE DIAS COM E SEM PRODUÇÃO
    # --------------------------------------------------
    # Para cada loja e dia, se o produto não produziu → Sem Produção
    df_dia = df_base[["Nome_Loja", "Data", "dia_sem_producao"]].copy()


    df_dia["dia_sem_producao"] = df_dia["dia_sem_producao"].fillna(1).astype(int)

    df_dia["Status"] = np.where(
        df_dia["dia_sem_producao"] == 1,
        "Não Houve Produção",
        "Houve Produção"
    )

    # --------------------------------------------------
    # TOTAIS E RANKING
    # --------------------------------------------------
    totais = (
        df_dia[df_dia["Status"] == "Não Houve Produção"]
        .groupby("Nome_Loja")["Data"]
        .nunique()
        .reset_index(name="Dias Sem Produção")
    )

    ranking_lojas = (
        totais
        .sort_values("Dias Sem Produção", ascending=False)["Nome_Loja"]
        .tolist()
    )

    df_dia["Nome_Loja"] = pd.Categorical(
        df_dia["Nome_Loja"],
        categories=ranking_lojas,
        ordered=True
    )

    # --------------------------------------------------
    # TÍTULO
    # --------------------------------------------------
    st.title(f"Matriz de Lojas Zeradas D-1 - {produto}")

    # --------------------------------------------------
    # GRÁFICO SCATTER (MAPA)
    # --------------------------------------------------
    import plotly.express as px

    fig = px.scatter(
        df_dia,
        x="Data",
        y="Nome_Loja",
        color="Status",
        labels={
            "Nome_Loja": "Loja",
            "Data": "Data",
            "Status": "Status"
        },
        color_discrete_map={
            "Houve Produção": "#2E7D32",
            "Não Houve Produção": "#C62828"
        },
        height=420
    )
    # RANKING
    fig.update_yaxes(
        categoryorder="array",
        categoryarray=ranking_lojas
    )

    fig.update_traces(
        hovertemplate=
            "<b>Loja:</b> %{y}<br>"
            "<b>Data:</b> %{x|%d/%m}<br>"
            "<b>Status:</b> %{customdata[0]}"
            "<extra></extra>"
    )

    fig.update_traces(
        marker=dict(size=16, line=dict(width=0.8, color="#333"))
    )

    # Linhas horizontais (efeito ranking)
    for i, _ in enumerate(ranking_lojas):
        fig.add_hline(
            y=i - 0.5,
            line_width=1,
            line_color="#E0E0E0",
            layer="below"
        )

    # Coluna de totais à direita
    data_ref = df_dia["Data"].max().strftime("%d/%m")
    for _, row in totais.iterrows():
        fig.add_annotation(
            x=df_dia["Data"].max() + pd.Timedelta(days=0.5),
            y=row["Nome_Loja"],
            text=f"<b>{int(row['Dias Sem Produção'])}</b>",
            showarrow=False,
            font=dict(size=13, color="#B71C1C")
        )

    fig.update_xaxes(
        range=[
            df_dia["Data"].min(),
            df_dia["Data"].max() + pd.Timedelta(days=1)
        ]
    )

    fig.update_layout(
        xaxis_title="Data",
        yaxis_title="Lojas",
        legend_title="Status",
        plot_bgcolor="white",
        dragmode=False,
        margin=dict(l=80, r=120, t=60, b=40)
    )

    st.plotly_chart(fig, use_container_width=True)
