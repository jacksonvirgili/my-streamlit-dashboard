# -*- coding: utf-8 -*-
"""Cópia de app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DtDWgPXGW4RqgLzfy1cxAdfjfPh_jn1W
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import re
import streamlit as st
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
import plotly.graph_objects as go
import plotly.express as px

# ------------------------------
# Configuração do app
# ------------------------------
st.set_page_config(layout='wide', page_icon="assets/icons/OIP.png")

# ------------------------------
# Carregamento do arquivo local
# ------------------------------
EXCEL_PATH = "consolidado.xlsx"

@st.cache_data(show_spinner=False)
def carregar_excel_local(caminho):
    """Carrega Excel local com múltiplas abas e retorna um dicionário de DataFrames"""
    try:
        xls = pd.read_excel(caminho, sheet_name=None)
        return xls
    except Exception as e:
        st.error(f"Erro ao carregar Excel: {e}")
        st.stop()

rede = carregar_excel_local(EXCEL_PATH)

# ------------------------------
# Função de limpeza de moeda
# ------------------------------
def limpar_moeda(valor):
    """Limpa valores monetários no formato R$ 1.234,56 -> 1234.56"""
    if pd.isna(valor):
        return 0.0
    if isinstance(valor, (int, float, np.number)):
        return valor
    if isinstance(valor, str):
        v = valor.strip()
        if v in ("-", ""):
            return 0.0
        v = v.replace("R$", "").replace("r$", "").strip()
        v = re.sub(r"\.(?=\d{3},)", "", v)
        v = v.replace(",", ".")
        try:
            return float(v)
        except:
            return 0.0
    return 0.0

# ------------------------------
# Colunas que precisam de conversão
# ------------------------------
colunas_para_converter = [
    'Real', 'Meta Mês', 'Ticket Médio',
    'Novo', 'Refin', 'PORT + Refin da Port >=1,85',
    'Refin da Port < 1,85', 'Rep. Legal', 'META AUMENTO MARGEM'
]

# ------------------------------
# Aplica função de limpeza a todas as abas
# ------------------------------
for nome_aba, df in rede.items():
    for col in colunas_para_converter:
        if col in df.columns and df[col].dtype == object:
            df[col] = df[col].apply(limpar_moeda)
    rede[nome_aba] = df  # garante atualização no dicionário

# ---------- CONVERTER COLUNA DE DATAS ---------- #
for nome_aba, df in rede.items():
    if 'Data' in df.columns:
        df['Data'] = pd.to_datetime(df['Data'], errors='coerce')
        rede[nome_aba] = df

# ---------- FUNÇÃO ADICIONAR DIAS ---------- #
def adicionar_dias(df):
    df = df.copy()
    if 'Data' in df.columns and 'Nome_Loja' in df.columns:
        df['ano_mes'] = df['Data'].dt.to_period('M')
        contagem = df.groupby(['Nome_Loja', 'ano_mes']).size().rename('DIAS')
        df = df.join(contagem, on=['Nome_Loja', 'ano_mes'])
        df = df.drop(columns=['ano_mes'])
    return df

# ---------- APLICAR FUNÇÃO EM TODAS AS ABAS ---------- #
for nome_aba, df in rede.items():
    rede[nome_aba] = adicionar_dias(df)

# ---------- PREENCHER META MÊS ---------- #
def preencher_meta_mes(df):
    df = df.copy()
    if 'Data' in df.columns and 'Nome_Loja' in df.columns and 'Meta Mês' in df.columns:
        df['ano_mes'] = df['Data'].dt.to_period('M')
        df['Meta Mês'] = (
            df['Meta Mês'].replace(0, pd.NA)
            .groupby([df['Nome_Loja'], df['ano_mes']])
            .transform(lambda x: x.bfill())
            .fillna(0)
        )
        df = df.drop(columns=['ano_mes'])
    return df

# Aplica a todas as abas
for nome_aba, df in rede.items():
    rede[nome_aba] = preencher_meta_mes(df)

# ---------- CALCULAR VARIAÇÃO ---------- #
def calcular_variacao(df):
    df = df.copy()
    if 'Data' in df.columns and 'Nome_Loja' in df.columns and 'Real' in df.columns:
        df["data_aux"] = df['Data']
        df["ano_mes"] = df["data_aux"].dt.to_period("M")
        df = df.sort_values(["Nome_Loja", "ano_mes", "data_aux"])

        def variacao_grupo(x):
            var = x - x.shift(1)
            var.iloc[0] = x.iloc[0]
            return var

        df["Real_Variacao"] = df.groupby(["Nome_Loja", "ano_mes"])["Real"].transform(variacao_grupo)
        df = df.drop(columns=["ano_mes", "data_aux"], errors='ignore')
    return df

# Aplica a todas as abas
for nome_aba, df in rede.items():
    rede[nome_aba] = calcular_variacao(df)

# ---------- CALCULAR META DIA ---------- #
def calcular_meta_dia(df):
    df = df.copy()
    if 'Meta Mês' in df.columns and 'DIAS' in df.columns:
        df['Meta Dia'] = df['Meta Mês'] / df['DIAS']
    return df

# Aplica a todas as abas
for nome_aba, df in rede.items():
    rede[nome_aba] = calcular_meta_dia(df)

rede = pd.concat(
    [df.assign(Produto=nome) for nome, df in rede.items()]
)

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from matplotlib import pyplot as plt
from matplotlib.ticker import FuncFormatter

# ------------------------------------------------------
# INÍCIO — TÍTULO PRINCIPAL
# ------------------------------------------------------
st.title("Desempenho Comercial")

paginas = [
    "Consolidado",
    "Ranking e Metas"
]

pagina = st.selectbox("Selecione a página:", paginas)

# ------------------------------------------------------
# FUNÇÕES COMPARTILHADAS (para ambas as páginas)
# ------------------------------------------------------

def format_large_numbers(value):
    if value is None or pd.isna(value):
        return ""
    return f"R$ {value:,.0f}".replace(",", ".")


def filtrar_df(rede, produto, regional, coordenador, loja, mes, ano):
    df_f = rede.copy()

    if produto != 'Todos':
        df_f = df_f[df_f['Produto'] == produto]
    if regional != 'Todas':
        df_f = df_f[df_f['Regional'] == regional]
    if coordenador != 'Todos':
        df_f = df_f[df_f['Coordenador'] == coordenador]
    if loja != 'Todas':
        df_f = df_f[df_f['Nome_Loja'] == loja]

    df_f = df_f[(df_f['Data'].dt.year == int(ano)) &
                (df_f['Data'].dt.month == int(mes))]

    return df_f


def calcular_acumulados(df_filtrado):
    df_grouped = df_filtrado.groupby('Data', as_index=False).agg({
        'DIAS': 'sum',
        'Real_Variacao': 'sum',
        'Meta Dia': 'sum'
    }).sort_values('Data').reset_index(drop=True)

    df_grouped['REAL_ACUM'] = df_grouped['Real_Variacao'].cumsum()
    df_grouped['META_ACUM'] = df_grouped['Meta Dia'].cumsum()

    df_grouped['DESVIO_DIA_PCT'] = (
        (df_grouped['Real_Variacao'] - df_grouped['Meta Dia']) /
        df_grouped['Meta Dia'].replace(0, np.nan) * 100
    ).fillna(0)

    df_grouped['DESVIO_ACUM'] = df_grouped['REAL_ACUM'] - df_grouped['META_ACUM']
    df_grouped['DESVIO_DIA_R$'] = (df_grouped['Real_Variacao'] - df_grouped['Meta Dia'])

    df_grouped['DESVIO_ACUM_PCT'] = (
        (df_grouped['REAL_ACUM'] - df_grouped['META_ACUM']) /
        df_grouped['META_ACUM'].replace(0, np.nan) * 100
    ).fillna(0)

    return df_grouped


def aplicar_estilo(fig):
    fig.update_layout(
        template="plotly_white",
        autosize=True,
        dragmode=False,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1,
            xanchor="left",
            x=0,
            bgcolor="rgba(255,255,255,0.5)",
            bordercolor="rgba(0,0,0,0.15)",
            borderwidth=1
        ),
        margin=dict(l=10, r=10, t=120, b=10),
        font=dict(size=12)
    )
    fig.update_xaxes(tickangle=30, automargin=True)
    fig.update_yaxes(automargin=True)
    return fig


# =====================================================
# FUNÇÃO DOS GRÁFICOS 2x2 (CONSOLIDADO)
# =====================================================
def plot_2x2(df_grouped, produto, mes, ano):

    st.subheader(f"{produto} — {mes}/{ano}")

    if not pd.api.types.is_datetime64_any_dtype(df_grouped["Data"]):
        df_grouped["Data"] = pd.to_datetime(df_grouped["Data"])

    first_day = pd.Timestamp(year=ano, month=mes, day=1)
    last_day = first_day + pd.offsets.MonthEnd(0)
    full_dates = pd.DataFrame({"Data": pd.date_range(first_day, last_day, freq="D")})

    df = full_dates.merge(df_grouped, on="Data", how="left")
    df["DataLabel"] = df["Data"].dt.strftime("%d/%m")

    df = df[~(df["Real_Variacao"].isna() & df["Meta Dia"].isna())]

    modo = st.radio(
        "Selecione a visualização:",
        ["Diário", "Acumulado"],
        horizontal=True
    )

    # ------- DIÁRIO -------
    if modo == "Diário":
        df["DesvioLabel"] = df['DESVIO_DIA_R$'].apply(lambda x: "Positivo" if x >= 0 else "Negativo")

        fig1 = go.Figure()
        fig1.add_bar(
            x=df["DataLabel"],
            y=df["Real_Variacao"],
            name='Real Dia',
            marker_color='#EA9411',
            hovertemplate='<b>Data:</b> %{x}<br><b>Real:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig1.add_scatter(
            x=df["DataLabel"],
            y=df["Meta Dia"],
            mode='lines+markers',
            name='Meta Dia',
            marker=dict(color='blue'),
            hovertemplate='<b>Data:</b> %{x}<br><b>Meta Dia:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig1.update_layout(title="Diário (R$)", xaxis_title="Data")
        fig1 = aplicar_estilo(fig1)
        st.plotly_chart(fig1, use_container_width=True)

        fig2 = go.Figure()
        fig2.add_bar(
            x=df["DataLabel"],
            y=df["DESVIO_DIA_R$"],
            marker_color=["#EA9411" if x >= 0 else "gray" for x in df["DESVIO_DIA_R$"]],
            hovertemplate='<b>Data:</b> %{x}<br><b>Desvio Diário:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig2.add_hline(y=0, line_color="blue")
        fig2.update_layout(title="Desvio Diário R$")
        fig2 = aplicar_estilo(fig2)
        st.plotly_chart(fig2, use_container_width=True)

    # ------- ACUMULADO -------
    else:
        df["DesvioAcumLabel"] = df["DESVIO_ACUM"].apply(lambda x: "Positivo" if x >= 0 else "Negativo")

        fig3 = go.Figure()
        fig3.add_bar(
            x=df["DataLabel"],
            y=df["REAL_ACUM"],
            name='Real Acumulado',
            marker_color='#EA9411',
            hovertemplate='<b>Data:</b> %{x}<br><b>Real:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig3.add_scatter(
            x=df["DataLabel"],
            y=df["META_ACUM"],
            mode='lines+markers',
            name='Meta Acumulada',
            marker=dict(color='blue'),
            hovertemplate='<b>Data:</b> %{x}<br><b>Meta:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig3.update_layout(title="Acumulado (R$)")
        fig3 = aplicar_estilo(fig3)
        st.plotly_chart(fig3, use_container_width=True)

        fig4 = go.Figure()
        fig4.add_bar(
            x=df["DataLabel"],
            y=df["DESVIO_ACUM"],
            marker_color=["#EA9411" if x >= 0 else "gray" for x in df["DESVIO_ACUM"]],
            hovertemplate='<b>Data:</b> %{x}<br><b>Desvio:</b> R$ %{y:,.2f}<extra></extra>'
        )
        fig4.add_hline(y=0, line_color="blue")
        fig4.update_layout(title="Desvio Acumulado (R$)")
        fig4 = aplicar_estilo(fig4)
        st.plotly_chart(fig4, use_container_width=True)



# ------------------------------------------------------
# ###############   PÁGINA 1 — CONSOLIDADO   ###############
# ------------------------------------------------------

if pagina == "Consolidado":

    st.header("Consolidado")

    # ------------- SIDEBAR -------------
    st.sidebar.header("Filtros")

    produtos = ['Todos'] + sorted(rede['Produto'].dropna().unique().tolist())
    produto_sel = st.sidebar.selectbox("Produto", produtos, index=0)

    regionais = ['Todas'] + sorted(rede['Regional'].dropna().unique().tolist())
    regional_sel = st.sidebar.selectbox("Regional", regionais, index=0)

    df_reg = rede.copy()
    if regional_sel != 'Todas':
        df_reg = df_reg[df_reg['Regional'] == regional_sel]

    coordenadores = ['Todos'] + sorted(df_reg['Coordenador'].dropna().unique().tolist())
    coordenador_sel = st.sidebar.selectbox("Coordenador", coordenadores, index=0)

    df_coord = df_reg.copy()
    if coordenador_sel != 'Todos':
        df_coord = df_coord[df_coord['Coordenador'] == coordenador_sel]

    lojas = ['Todas'] + sorted(df_coord['Nome_Loja'].dropna().unique().tolist())
    loja_sel = st.sidebar.selectbox("Loja", lojas, index=0)

    anos = sorted(rede['Data'].dt.year.unique().tolist())
    anos_sel = st.sidebar.selectbox("Ano", anos, index=len(anos)-1)

    meses = sorted(rede['Data'].dt.month.unique().tolist())
    mes_sel = st.sidebar.selectbox("Mês", meses, index=0)

    # ------------ PROCESSAR DADOS ------------
    df_f = filtrar_df(rede, produto_sel, regional_sel, coordenador_sel, loja_sel, mes_sel, anos_sel)

    if df_f.empty:
        st.warning("Nenhum dado após aplicar os filtros.")
        st.stop()

    df_grouped = calcular_acumulados(df_f)

    st.markdown(
        f"**Produto:** {produto_sel}  •  **Regional:** {regional_sel}  •  "
        f"**Coordenador:** {coordenador_sel}  •  **Loja:** {loja_sel}  •  "
        f"**Período:** {mes_sel}/{anos_sel}"
    )

    # ------------ PLOTAR GRÁFICOS ------------
    plot_2x2(df_grouped, produto_sel, mes_sel, anos_sel)

    # ------------ TABELA FINAL ------------
    st.subheader("Tabela Consolidada")

    df_exibir = df_grouped.copy()

    # Remover colunas da tabela final
    cols_remover = ["DIAS", "Real_Variacao", "REAL_ACUM", "META_ACUM", "DESVIO_ACUM","DESVIO_DIA_R$"]
    df_exibir = df_exibir.drop(columns=[c for c in cols_remover if c in df_exibir.columns])

    # Renomear colunas
    df_exibir = df_exibir.rename(columns={
        "DESVIO_DIA_PCT": "Desvio Dia %",
        "DESVIO_ACUM_PCT": "Desvio Acumulado %"
    })

    # Formatar %
    df_exibir["Desvio Dia %"] = df_exibir["Desvio Dia %"].apply(lambda x: f"{x:.2f}%")
    df_exibir["Desvio Acumulado %"] = df_exibir["Desvio Acumulado %"].apply(lambda x: f"{x:.2f}%")

    # Criar colunas usando df_grouped (não df_exibir)
    df_exibir['Producao Dia'] = df_grouped['Real_Variacao'].apply(format_large_numbers)
    df_exibir['Meta Dia'] = df_grouped['Meta Dia'].apply(format_large_numbers)
    df_exibir['Producao Acumulada'] = df_grouped['REAL_ACUM'].apply(format_large_numbers)
    df_exibir['Meta Acumulada'] = df_grouped['META_ACUM'].apply(format_large_numbers)
    df_exibir['Desvio Acumulado'] = df_grouped['DESVIO_ACUM'].apply(format_large_numbers)
    df_exibir['Desvio Dia'] = df_grouped['DESVIO_DIA_R$'].apply(format_large_numbers)

    ordem = [
        "Data",
        "Producao Dia",
        "Meta Dia",
        "Desvio Dia",
        "Desvio Dia %",
        "Producao Acumulada",
        "Meta Acumulada",
        "Desvio Acumulado",
        "Desvio Acumulado %"

    ]

    df_exibir = df_exibir[ordem]

    # Exibir
    st.dataframe(df_exibir, use_container_width=True)

    # CSV (mesma lógica)
    df_csv = df_grouped.copy()
    df_csv = df_csv.drop(columns=[c for c in cols_remover if c in df_csv.columns])
    df_csv = df_csv.rename(columns={
        "DESVIO_DIA_PCT": "Desvio Dia %",
        "DESVIO_ACUM_PCT": "Desvio Acumulado %"
    })

    csv = df_csv.to_csv(index=False).encode('utf-8-sig')

    st.download_button(
        label="Baixar tabela em CSV",
        data=csv,
        file_name=f"consolidado_{mes_sel}_{anos_sel}.csv",
        mime="text/csv"
    )

# ------------------------------------------------------
# ###############   PÁGINA 2 — RANKING E METAS   ###############
# ------------------------------------------------------

elif pagina == "Ranking e Metas":

    st.header("Ranking e Metas")

    # ------------------ SIDEBAR ------------------
    st.sidebar.header("Filtros — Ranking")

    # Filtros dinâmicos
    regionais = ['Todas'] + sorted(rede['Regional'].dropna().unique())
    regional_widget = st.sidebar.selectbox("Regional", regionais, index=0)

    df_filtros = rede.copy()
    if regional_widget != 'Todas':
        df_filtros = df_filtros[df_filtros['Regional'] == regional_widget]

    coordenadores = ['Todos'] + sorted(df_filtros['Coordenador'].dropna().unique())
    coordenador_widget = st.sidebar.selectbox("Coordenador", coordenadores, index=0)

    if coordenador_widget != 'Todos':
        df_filtros = df_filtros[df_filtros['Coordenador'] == coordenador_widget]

    produtos = ['Todos'] + sorted(df_filtros['Produto'].dropna().unique())
    produto_widget = st.sidebar.selectbox("Produto", produtos, index=0)

    anos = sorted(rede['Data'].dt.year.unique())
    ano_widget = st.sidebar.selectbox("Ano", anos, index=len(anos)-1)

    meses = sorted(rede['Data'].dt.month.unique())
    mes_widget = st.sidebar.selectbox("Mês", meses, index=0)

    tipo_ranking = st.radio(
        "Tipo de Ranking",
        ["Produção", "Desvio da Meta"],
        index=0
    )

    # ----------------------------------------------------
    # FUNÇÃO AUXILIAR PARA APLICAR FILTROS
    # ----------------------------------------------------
    def filtrar_dados(produto, regional, coordenador, mes, ano):
        df = rede.copy()

        if regional != 'Todas':
            df = df[df['Regional'] == regional]

        if coordenador != 'Todos':
            df = df[df['Coordenador'] == coordenador]
            grupo = 'Nome_Loja'
        else:
            grupo = 'Coordenador'

        if produto != 'Todos':
            df = df[df['Produto'] == produto]

        df = df[(df['Data'].dt.month == mes) & (df['Data'].dt.year == ano)]

        return df, grupo

    # ----------------------------------------------------
    # FUNÇÃO 1 — RANKING REAL X META
    # ----------------------------------------------------
    def plot_ranking(produto, regional, coordenador, mes, ano):
        df_f, grupo = filtrar_dados(produto, regional, coordenador, mes, ano)

        if df_f.empty:
            st.warning("Nenhum dado após aplicar os filtros.")
            return pd.DataFrame(), grupo

        ranking = df_f.groupby(grupo)[['Real_Variacao', 'Meta Dia']].sum().reset_index()
        ranking.rename(columns={'Real_Variacao': 'Real_Acumulada', 'Meta Dia': 'Meta_Acumulada'}, inplace=True)

        # Peso total = Real acumulado do grupo / Real acumulado total
        total_real = ranking['Real_Acumulada'].sum()
        ranking['Peso_Producao_%'] = ranking['Real_Acumulada'] / total_real

        # Desvio %
        ranking['Desvio_%'] = (ranking['Real_Acumulada'] - ranking['Meta_Acumulada']) / ranking['Meta_Acumulada']

        # Impacto = Desvio% × Peso
        ranking['Impacto'] = ranking['Desvio_%'] * ranking['Peso_Producao_%']

        ranking.sort_values('Real_Acumulada', inplace=True)

        # Quebra o nome em duas linhas
        def wrap(texto):
            palavras = texto.split()
            if len(palavras) <= 1:
                return texto
            meio = len(palavras) // 2
            return f"{' '.join(palavras[:meio])}<br>{' '.join(palavras[meio:])}"

        ranking["label_wrap"] = ranking[grupo].apply(wrap)

        fig = go.Figure()

        fig.add_bar(
            y=ranking["label_wrap"],
            x=ranking['Real_Acumulada'],
            orientation='h',
            name="Real Acumulado",
            marker_color="#EA9411",
            hovertemplate="<b>%{y}</b><br>Real: R$ %{x:,.0f}<extra></extra>"
        )

        fig.add_scatter(
            y=ranking["label_wrap"],
            x=ranking['Meta_Acumulada'],
            mode='markers',
            name="Meta Acumulada",
            marker=dict(size=8, symbol="diamond", color="blue"),
            hovertemplate="<b>%{y}</b><br>Meta: R$ %{x:,.0f}<extra></extra>"
        )

        fig.update_layout(
            title=f"Ranking {grupo} ({mes}/{ano})",
            template="plotly_white",
            height=len(ranking) * 60,
            dragmode=False,
            legend=dict(
                orientation="h",  # horizontal
                yanchor="bottom",
                y=0.98,           # acima do gráfico
                xanchor="center",
                x=0.5
            )
        )

        st.plotly_chart(fig, use_container_width=True)

        return ranking, grupo

    # ----------------------------------------------------
    # FUNÇÃO 2 — RANKING POR DESVIO
    # ----------------------------------------------------
    def plot_ranking_desvio(produto, regional, coordenador, mes, ano):
        df_f, grupo = filtrar_dados(produto, regional, coordenador, mes, ano)

        if df_f.empty:
            st.warning("Nenhum dado após aplicar os filtros.")
            return pd.DataFrame(), grupo

        ranking = df_f.groupby(grupo)[['Real_Variacao', 'Meta Dia']].sum().reset_index()
        ranking['Desvio'] = ranking['Real_Variacao'] - ranking['Meta Dia']

        # Peso total = Real acumulado / total
        total_real = ranking['Real_Variacao'].sum()
        ranking['Peso_Producao_%'] = ranking['Real_Variacao'] / total_real

        # Desvio %
        ranking['Desvio_%'] = ranking['Desvio'] / ranking['Meta Dia']

        # Impacto
        ranking['Impacto'] = ranking['Desvio_%'] * ranking['Peso_Producao_%']

        ranking['Cor'] = ranking['Desvio'].apply(lambda x: "#EA9411" if x > 0 else "gray")
        ranking.sort_values('Desvio', inplace=True)

        # Quebra o nome em duas linhas
        def wrap(texto):
            palavras = texto.split()
            if len(palavras) <= 1:
                return texto
            meio = len(palavras) // 2
            return f"{' '.join(palavras[:meio])}<br>{' '.join(palavras[meio:])}"

        ranking["label_wrap"] = ranking[grupo].apply(wrap)

        fig = go.Figure()

        fig.add_bar(
            y=ranking["label_wrap"],
            x=ranking["Desvio"],
            orientation="h",
            marker_color=ranking['Cor'],
            name="Desvio (valor)",
            hovertemplate="<b>%{y}</b><br>Desvio: R$ %{x:,.0f}<extra></extra>"
        )

        fig.update_layout(
            title=f"Ranking por Desvio — {grupo} ({mes}/{ano})",
            template="plotly_white",
            height=len(ranking) * 50,
            xaxis_title="Desvio (Valor)",
            dragmode=False,
        )

        st.plotly_chart(fig, use_container_width=True)

        return ranking, grupo

    # ----------------------------------------------------
    # FUNÇÃO — TABELA E DOWNLOAD (COMPARTILHADA)
    # ----------------------------------------------------
    def gerar_tabela_ranking(ranking, grupo, mes, ano, tipo_ranking):
        st.subheader("Tabela de Ranking")

        df_tab = ranking.copy()

        # ----------------------------------------------------
        # 1. RENOMEAR COLUNAS PARA EXIBIÇÃO
        # ----------------------------------------------------
        rename_map = {
            'Real_Variacao': 'Produção_Mensal',
            'Meta Dia': 'Meta_Mensal',
            'Real_Acumulada': 'Produção Mensal',
            'Meta_Acumulada': 'Meta Mensal'
        }
        df_tab = df_tab.rename(columns={k: v for k, v in rename_map.items() if k in df_tab.columns})

        # ----------------------------------------------------
        # 2. REMOVER COLUNAS AUXILIARES
        # ----------------------------------------------------
        if tipo_ranking == "Produção":
            if 'label_wrap' in df_tab.columns:
                df_tab = df_tab.drop(columns=['label_wrap'])
        else:  # Ranking por Desvio
            cols_to_drop = [c for c in ['label_wrap', 'Cor'] if c in df_tab.columns]
            if cols_to_drop:
                df_tab = df_tab.drop(columns=cols_to_drop)

        # ----------------------------------------------------
        # 3. GARANTIR COLUNA 'Desvio' (R$) NO RANKING PRODUÇÃO
        # ----------------------------------------------------
        if tipo_ranking == "Produção":
            # Esperamos que o ranking de Produção tenha Real_Acumulada e Meta_Acumulada
            if 'Produção Mensal' in df_tab.columns and 'Meta Mensal' in df_tab.columns:
                df_tab['Produção Mensal'] = pd.to_numeric(df_tab['Produção Mensal'], errors='coerce')
                df_tab['Meta Mensal'] = pd.to_numeric(df_tab['Meta Mensal'], errors='coerce')
                df_tab['Desvio'] = df_tab['Produção Mensal'] - df_tab['Meta Mensal']
        else:
            # No ranking por Desvio assumimos que 'Desvio' já existe no dataframe (calculado em plot_ranking_desvio)
            # Não criamos 'Desvio R$' extra aqui.
            pass

        # ----------------------------------------------------
        # 4. FORMATAÇÃO NÚMEROS GRANDES (R$)
        # ----------------------------------------------------
        for col in ['Produção_Mensal', 'Meta_Mensal', 'Produção Mensal', 'Meta Mensal', 'Desvio']:
            if col in df_tab.columns:
                df_tab[col] = df_tab[col].apply(lambda x: format_large_numbers(x) if pd.notna(x) and x != "" else "")

        # ----------------------------------------------------
        # 5. FORMATAR PORCENTAGENS
        # ----------------------------------------------------
        if 'Desvio_%' in df_tab.columns:
            df_tab['Desvio_%'] = (df_tab['Desvio_%'] * 100).round(2).astype(str) + '%'
        if 'Peso_Producao_%' in df_tab.columns:
            df_tab['Peso_Producao_%'] = (df_tab['Peso_Producao_%'] * 100).round(2).astype(str) + '%'
        if 'Impacto' in df_tab.columns:
            df_tab['Impacto'] = (df_tab['Impacto'] * 100).round(2).astype(str) + '%'

        # ----------------------------------------------------
        # 6. ORDEM DAS COLUNAS
        # ----------------------------------------------------
        if tipo_ranking == "Produção":
            ordem = [
                grupo,
                "Produção Mensal",
                "Meta Mensal",
                "Desvio",
                "Peso_Producao_%",
                "Desvio_%",
                "Impacto"
            ]
        else:
            ordem = [
                grupo,
                'Produção_Mensal',
                "Meta_Mensal",
                "Desvio",
                "Peso_Producao_%",
                "Desvio_%",
                "Impacto"
            ]

        ordem_final = [c for c in ordem if c in df_tab.columns]
        df_tab = df_tab.reindex(columns=ordem_final)

        # ----------------------------------------------------
        # 7. ESTILO (Impacto em cinza)
        # ----------------------------------------------------
        if 'Impacto' in df_tab.columns:
            df_tab_styled = df_tab.style.applymap(
                lambda x: 'background-color: #4d4d4d; color: white;' if isinstance(x, str) and x.endswith('%') else '',
                subset=['Impacto']
            )
            st.dataframe(df_tab_styled, use_container_width=True)
        else:
            st.dataframe(df_tab, use_container_width=True)

        # ----------------------------------------------------
        # 8. DOWNLOAD CSV
        # ----------------------------------------------------
        csv = df_tab.to_csv(index=False, encoding='utf-8-sig')
        st.download_button(
            label="Baixar tabela em CSV",
            data=csv,
            file_name=f"ranking_{grupo}_{mes}_{ano}.csv",
            mime="text/csv"
        )

    # ----------------------------------------------------
    # EXECUÇÃO — GRÁFICO + TABELA (compartilhada)
    # ----------------------------------------------------
    if tipo_ranking == "Produção":
        ranking, grupo = plot_ranking(produto_widget, regional_widget, coordenador_widget, mes_widget, ano_widget)
    else:
        ranking, grupo = plot_ranking_desvio(produto_widget, regional_widget, coordenador_widget, mes_widget, ano_widget)

    gerar_tabela_ranking(ranking, grupo, mes_widget, ano_widget, tipo_ranking)